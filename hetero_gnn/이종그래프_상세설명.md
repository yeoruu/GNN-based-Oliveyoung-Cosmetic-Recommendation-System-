# 🌐 이종 그래프(Heterogeneous Graph) GNN 상세 설명

## 📊 그래프 구조

### 노드 타입 (5종)
```
1. Product (제품) - 607개
2. SkinType (피부 타입) - 7개
3. Ingredient (성분) - 1,682개
4. Category (카테고리) - 5개
5. Brand (브랜드) - 158개
```

### 엣지 타입 (8종)
```
→ 방향: Source → Target

1. SkinType → Product: "reviewed"
   (이 피부 타입을 가진 유저가 리뷰한 제품)

2. Product → SkinType: "rev_reviewed" (역방향)

3. Product → Category: "in_category"
   (제품이 속한 카테고리)

4. Category → Product: "rev_in_category" (역방향)

5. Product → Ingredient: "contains"
   (제품이 포함한 성분)

6. Ingredient → Product: "rev_contains" (역방향)

7. Product → Brand: "made_by"
   (제품을 만든 브랜드)

8. Brand → Product: "rev_made_by" (역방향)
```

---

## 🔍 기존 모델과의 차이점

### 기존 모델 (Homogeneous Graph)
```
노드 타입: 3개
- Product
- Ingredient  
- User

문제점:
❌ 유저 정보가 단순 노드
❌ 피부 타입 정보 미활용
❌ 카테고리, 브랜드 정보 무시
```

### 새 모델 (Heterogeneous Graph)
```
노드 타입: 5개
- Product
- SkinType (핵심!)
- Ingredient
- Category (새로 추가!)
- Brand (새로 추가!)

장점:
✅ 피부 타입을 명시적 노드로
✅ 한 유저가 여러 피부 타입 가능
✅ 카테고리, 브랜드 정보 활용
✅ 더 풍부한 메타 정보
```

---

## 🎯 핵심: 피부 타입 처리

### 1. 피부 타입 파싱

#### 입력 데이터
```python
# final_total_reviews.csv
user_keywords = "건성"              → ['건성']
user_keywords = "지성 | 복합성"     → ['지성', '복합성']
user_keywords = "건성,민감성"       → ['건성', '민감성']
```

#### 코드
```python
def parse_skintype(skintype_str):
    # "건성", "지성 | 복합성", "건성,민감성" 처리
    for sep in ['|', ',', '/']:
        if sep in skintype_str:
            skintypes = [s.strip() for s in skintype_str.split(sep)]
            break
    return skintypes
```

### 2. 엣지 생성

```python
# 한 유저가 여러 피부 타입을 가질 때

user_id = "user1"
product_id = "L1"  
skintypes = ["건성", "민감성"]
rating = 5

# 엣지 생성:
SkinType[건성] → Product[L1]
SkinType[민감성] → Product[L1]

# 이렇게 하면:
# - "건성" 유저들의 선호도
# - "민감성" 유저들의 선호도
# 두 가지를 모두 학습!
```

---

## 🏗️ 그래프 구조 예시

### 실제 데이터 예시
```
제품: "스킨 베리어 카밍 로션" (L1)

[Product L1] 연결 관계:
├─ SkinType
│   ├─ "건성" → reviewed → [Product L1]
│   ├─ "복합성" → reviewed → [Product L1]
│   └─ "민감성" → reviewed → [Product L1]
│
├─ Category
│   └─ [Product L1] → in_category → "로션"
│
├─ Ingredient
│   ├─ [Product L1] → contains → "글리세린"
│   ├─ [Product L1] → contains → "세라마이드"
│   └─ [Product L1] → contains → "히알루론산"
│
└─ Brand
    └─ [Product L1] → made_by → "온그리디언츠"
```

---

## 🧠 GNN이 학습하는 패턴

### 패턴 1: 피부 타입별 선호 성분
```
[GNN 학습 과정]

건성 피부 유저들이 리뷰한 제품들:
SkinType[건성] → Product A → contains → 세라마이드
SkinType[건성] → Product B → contains → 세라마이드  
SkinType[건성] → Product C → contains → 세라마이드

GNN 학습:
"건성 피부는 세라마이드를 선호한다!"

추천:
→ 세라마이드 포함 신제품을 건성 피부에 추천
```

### 패턴 2: 복합 피부 타입
```
user1: ["건성", "민감성"]

엣지:
SkinType[건성] → Product X
SkinType[민감성] → Product X

GNN 학습:
- Product X는 건성에도 좋고
- 민감성에도 좋은 제품!

추천:
→ 건성+민감성 유저에게 적합한 제품 발견
```

### 패턴 3: 브랜드-카테고리-성분 관계
```
[복합 패턴 학습]

브랜드 A의 "세럼" 제품들:
Brand[A] ← Product[세럼1] → Ingredient[나이아신아마이드]
Brand[A] ← Product[세럼2] → Ingredient[나이아신아마이드]
                    ↓
              Category[세럼]

GNN 학습:
"브랜드 A의 세럼은 나이아신아마이드가 특징"

추천:
→ 나이아신아마이드 선호 유저에게 브랜드 A 세럼 추천
```

---

## 💻 코드 작동 원리

### 1. 그래프 구축

```python
# 피부 타입 → 제품 엣지
for review in reviews:
    product_idx = review['product_idx']
    
    # 한 유저가 여러 피부 타입 가능!
    for skintype in ["건성", "민감성"]:
        skintype_idx = skintype_to_idx[skintype]
        
        # 엣지 추가
        edges.append([skintype_idx, product_idx])
```

### 2. 이종 GNN Forward Pass

```python
# HeteroConv: 각 엣지 타입마다 별도의 GNN 레이어
class HeteroGNN(nn.Module):
    def forward(self, x_dict, edge_index_dict):
        # x_dict = {
        #   'product': [607 x 128],
        #   'skintype': [7 x 128],
        #   'ingredient': [1682 x 128],
        #   ...
        # }
        
        # 각 엣지 타입별로 메시지 전달
        for edge_type in edge_types:
            # skintype → product
            # product → ingredient
            # product → category
            # etc.
            message_passing(edge_type)
        
        return x_dict  # 업데이트된 임베딩
```

### 3. 추천 생성

```python
# "건성" 피부에 대한 추천
skintype = "건성"
skintype_idx = skintype_to_idx[skintype]  # 예: 0

# 모든 제품과 매칭
for product_idx in range(num_products):
    # GNN으로 임베딩 추출
    skintype_emb = embeddings['skintype'][skintype_idx]
    product_emb = embeddings['product'][product_idx]
    
    # 평점 예측
    rating = predict(skintype_emb, product_emb)

# Top-K 추천
```

---

## 📈 예상 성능 향상

### 기존 모델 대비 개선점

```
1. 피부 타입 정보 활용
   기존: 유저 ID만 사용
   신규: 피부 타입 패턴 학습
   → Cold Start 문제 완화

2. 복합 피부 타입 지원
   기존: 한 유저 = 하나의 노드
   신규: 한 유저 = 여러 피부 타입 노드
   → 더 정확한 매칭

3. 메타 정보 활용
   신규: 카테고리, 브랜드 정보
   → 더 풍부한 컨텍스트

4. 설명 가능성
   "건성 피부가 선호하는 세라마이드 포함 제품"
   → 추천 이유 명확
```

### 예상 지표
```
RMSE: 0.35 ~ 0.42 (기존: 0.45)
Accuracy: 93% ~ 95% (기존: 92.87%)
Hit Rate: 유지 또는 향상
```

---

## 🎯 실무 활용 예시

### 1. 피부 타입별 맞춤 추천
```python
# "건성 + 민감성" 유저
rec_system.recommend_by_skintype("건성", top_k=10)
rec_system.recommend_by_skintype("민감성", top_k=10)

# 두 결과의 교집합 = 최적 제품!
```

### 2. 신제품 마케팅
```python
# 신제품의 타겟 피부 타입 예측
new_product = "세라마이드 세럼"

# 각 피부 타입에 대한 예상 평점
for skintype in all_skintypes:
    rating = predict(skintype, new_product)

# 가장 높은 평점 → 타겟 고객
```

### 3. 브랜드 전략
```python
# 우리 브랜드가 강한 피부 타입은?
brand = "온그리디언츠"

for skintype in skintypes:
    avg_rating = avg_rating_by_brand_skintype(brand, skintype)

# 결과: "건성 피부에서 특히 인기!"
```

---

## 🔄 일반 그래프 vs 이종 그래프

### 일반 그래프 (Homogeneous)
```
[User1] ──── [Product A] ──── [Ingredient X]
   │              │                 │
[User2] ──── [Product B] ──── [Ingredient Y]

문제점:
- 모든 노드가 같은 타입
- 엣지도 같은 의미
- 정보 손실
```

### 이종 그래프 (Heterogeneous)
```
[건성] ──reviewed──> [Product A] ──contains──> [세라마이드]
  │                      │                         │
  │                      │                         │
  └──> [Product B] <──in_category── [로션]
           │
           └──made_by──> [온그리디언츠]

장점:
✅ 각 노드 타입마다 다른 의미
✅ 각 엣지 타입마다 다른 관계
✅ 더 풍부한 표현력
```

---

## 💡 핵심 아이디어

### 왜 피부 타입을 노드로?

```
기존 방식:
User [피부타입=건성] → Product

문제:
- 유저마다 리뷰 수가 다름
- 새 유저 추천 어려움 (Cold Start)

새 방식:
SkinType[건성] → Product

장점:
✅ 모든 "건성" 유저의 집단 지성
✅ 신규 유저도 피부 타입만 알면 추천 가능
✅ 피부 타입별 패턴 명확히 학습
```

---

## 🎓 실행 결과 해석

### 출력 예시
```
👤 피부 타입: 건성
────────────────────────────────────────

1. 세라마이드 인텐시브 크림
   브랜드: 제로이드 | 카테고리: 크림
   예상 평점: 4.85/5.0
   주요 성분: 세라마이드, 글리세린, 스쿠알란

2. 하이알루론 모이스처 세럼
   브랜드: 라운드랩 | 카테고리: 에센스/세럼/앰플
   예상 평점: 4.78/5.0
   주요 성분: 히알루론산, 글리세린, 판테놀
```

### 해석
```
GNN이 학습한 것:
1. "건성" 피부 유저들이 높게 평가한 제품들
2. 그 제품들의 공통 성분 (세라마이드, 히알루론산)
3. 그 성분들이 많은 새 제품도 추천!

결과:
→ 건성 피부에 최적화된 추천
→ 성분 기반이라 신제품도 추천 가능
→ 설명 가능 ("세라마이드가 건성에 좋아서")
```

---

## ✨ 요약

### 이종 그래프의 핵심
```
1. 피부 타입 → 독립 노드
   한 유저가 여러 피부 타입 가능!
   
2. 다양한 메타 정보
   카테고리, 브랜드, 성분 모두 활용
   
3. 타입별 메시지 전달
   각 관계마다 다른 의미로 학습
   
4. 강력한 추천
   - 피부 타입별 맞춤 추천
   - Cold Start 해결
   - 설명 가능한 추천
```

### 차별화 포인트
```
✅ 피부 타입 = 독립 노드
✅ 복합 피부 타입 지원
✅ 브랜드/카테고리 정보 활용
✅ 더 정교한 추천
✅ 더 높은 정확도
```

**이제 실행해보세요!** 🚀
